---
title: "Interactive WebGL Graphics: OpenGL Fundamentals in Your Browser"
publishedAt: "2025-01-19"
summary:
    "Learn OpenGL/WebGL fundamentals with interactive examples that run directly in your browser - from basic triangles to 3D objects with shaders and lighting"
---

## Introduction

WebGL brings the power of OpenGL to the web browser, allowing you to create stunning 3D graphics that run anywhere without plugins. In this interactive tutorial, you'll learn OpenGL fundamentals through working WebGL examples that you can experiment with right here in your browser.

WebGL is based on OpenGL ES 2.0, so the concepts you learn here translate directly to desktop OpenGL, mobile development, and other graphics APIs.

## Setting Up WebGL Context

Unlike desktop OpenGL, WebGL runs in the browser using an HTML5 canvas element. Let's start with the basic setup:

### HTML Canvas Setup

```html
<canvas id="webgl-canvas" width="800" height="600"></canvas>
<script>
// Get WebGL context
const canvas = document.getElementById('webgl-canvas');
const gl = canvas.getContext('webgl2') || canvas.getContext('webgl');

if (!gl) {
    alert('WebGL not supported');
    throw new Error('WebGL not supported');
}

// Set viewport
gl.viewport(0, 0, canvas.width, canvas.height);
console.log('WebGL context created successfully!');
</script>
```

<div style={{border: '1px solid #ccc', padding: '20px', margin: '20px 0', background: '#f9f9f9'}}>
<canvas id="demo-canvas-1" width="400" height="300" style={{border: '1px solid #333', display: 'block', margin: '0 auto'}}></canvas>
<p style={{textAlign: 'center', marginTop: '10px'}}><em>Canvas with WebGL context (check console for confirmation)</em></p>
</div>

<script>
{`
// Demo 1: Basic WebGL context
const canvas1 = document.getElementById('demo-canvas-1');
if (canvas1) {
    const gl1 = canvas1.getContext('webgl2') || canvas1.getContext('webgl');
    if (gl1) {
        gl1.clearColor(0.2, 0.3, 0.4, 1.0);
        gl1.clear(gl1.COLOR_BUFFER_BIT);
        console.log('Demo 1: WebGL context created successfully!');
    }
}
`}
</script>

## Understanding the Graphics Pipeline

WebGL uses the same graphics pipeline as OpenGL with these key stages:

1. **Vertex Shader**: Processes individual vertices and transforms them to screen space
2. **Rasterization**: Converts primitives (triangles) into fragments (pixels)
3. **Fragment Shader**: Determines the final color of each pixel

## Your First Triangle

Let's create the classic "Hello Triangle" - the foundation of all 3D graphics:

### Interactive Triangle Example

```javascript
// Vertex shader source (GLSL)
const vertexShaderSource = `
    attribute vec2 a_position;
    
    void main() {
        gl_Position = vec4(a_position, 0.0, 1.0);
    }
`;

// Fragment shader source (GLSL)
const fragmentShaderSource = `
    precision mediump float;
    
    void main() {
        gl_FragColor = vec4(1.0, 0.5, 0.2, 1.0); // Orange color
    }
`;

// Helper function to create and compile shader
function createShader(gl, type, source) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        console.error('Shader compilation error:', gl.getShaderInfoLog(shader));
        gl.deleteShader(shader);
        return null;
    }
    return shader;
}

// Create shader program
function createProgram(gl, vertexShader, fragmentShader) {
    const program = gl.createProgram();
    gl.attachShader(program, vertexShader);
    gl.attachShader(program, fragmentShader);
    gl.linkProgram(program);
    
    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        console.error('Program linking error:', gl.getProgramInfoLog(program));
        gl.deleteProgram(program);
        return null;
    }
    return program;
}

// Triangle vertices (in normalized device coordinates)
const vertices = new Float32Array([
    -0.5, -0.5,  // Bottom left
     0.5, -0.5,  // Bottom right
     0.0,  0.5   // Top
]);

// Setup WebGL triangle
function setupTriangle(gl) {
    // Create shaders
    const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
    const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
    
    // Create program
    const program = createProgram(gl, vertexShader, fragmentShader);
    
    // Create buffer for triangle vertices
    const positionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
    
    // Get attribute location
    const positionLocation = gl.getAttribLocation(program, 'a_position');
    
    return { program, positionBuffer, positionLocation };
}

// Render triangle
function renderTriangle(gl, triangle) {
    gl.clearColor(0.0, 0.0, 0.0, 1.0);
    gl.clear(gl.COLOR_BUFFER_BIT);
    
    gl.useProgram(triangle.program);
    
    gl.bindBuffer(gl.ARRAY_BUFFER, triangle.positionBuffer);
    gl.enableVertexAttribArray(triangle.positionLocation);
    gl.vertexAttribPointer(triangle.positionLocation, 2, gl.FLOAT, false, 0, 0);
    
    gl.drawArrays(gl.TRIANGLES, 0, 3);
}
```

<div style={{border: '1px solid #ccc', padding: '20px', margin: '20px 0', background: '#f9f9f9'}}>
<canvas id="triangle-canvas" width="400" height="300" style={{border: '1px solid #333', display: 'block', margin: '0 auto'}}></canvas>
<p style={{textAlign: 'center', marginTop: '10px'}}><em>Interactive Triangle - Your first WebGL render!</em></p>
</div>

<script>
{`
// Demo 2: Triangle
const triangleCanvas = document.getElementById('triangle-canvas');
if (triangleCanvas) {
    const gl = triangleCanvas.getContext('webgl2') || triangleCanvas.getContext('webgl');
    if (gl) {
        // Vertex shader
        const vertexShaderSource = \`
            attribute vec2 a_position;
            void main() {
                gl_Position = vec4(a_position, 0.0, 1.0);
            }
        \`;
        
        // Fragment shader
        const fragmentShaderSource = \`
            precision mediump float;
            void main() {
                gl_FragColor = vec4(1.0, 0.5, 0.2, 1.0);
            }
        \`;
        
        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Shader error:', gl.getShaderInfoLog(shader));
                return null;
            }
            return shader;
        }
        
        function createProgram(gl, vertexShader, fragmentShader) {
            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error('Program error:', gl.getProgramInfoLog(program));
                return null;
            }
            return program;
        }
        
        const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
        const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
        const program = createProgram(gl, vertexShader, fragmentShader);
        
        const vertices = new Float32Array([
            -0.5, -0.5,
             0.5, -0.5,
             0.0,  0.5
        ]);
        
        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
        
        const positionLocation = gl.getAttribLocation(program, 'a_position');
        
        gl.viewport(0, 0, triangleCanvas.width, triangleCanvas.height);
        gl.clearColor(0.0, 0.0, 0.0, 1.0);
        gl.clear(gl.COLOR_BUFFER_BIT);
        
        gl.useProgram(program);
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.enableVertexAttribArray(positionLocation);
        gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
        gl.drawArrays(gl.TRIANGLES, 0, 3);
    }
}
`}
</script>

## Adding Colors and Animation

Let's enhance our triangle with vertex colors and time-based animation:

### Animated Rainbow Triangle

```javascript
// Enhanced vertex shader with color and time
const colorVertexShaderSource = `
    attribute vec2 a_position;
    attribute vec3 a_color;
    uniform float u_time;
    
    varying vec3 v_color;
    
    void main() {
        // Add rotation based on time
        float angle = u_time;
        float cos_a = cos(angle);
        float sin_a = sin(angle);
        
        vec2 rotated = vec2(
            a_position.x * cos_a - a_position.y * sin_a,
            a_position.x * sin_a + a_position.y * cos_a
        );
        
        gl_Position = vec4(rotated, 0.0, 1.0);
        v_color = a_color;
    }
`;

// Enhanced fragment shader
const colorFragmentShaderSource = `
    precision mediump float;
    varying vec3 v_color;
    uniform float u_time;
    
    void main() {
        // Pulse effect
        float pulse = (sin(u_time * 3.0) + 1.0) / 2.0;
        gl_FragColor = vec4(v_color * (0.5 + pulse * 0.5), 1.0);
    }
`;

// Vertices with color data
const colorVertices = new Float32Array([
    // positions    // colors (RGB)
    -0.5, -0.5,     1.0, 0.0, 0.0,  // Bottom left - Red
     0.5, -0.5,     0.0, 1.0, 0.0,  // Bottom right - Green
     0.0,  0.5,     0.0, 0.0, 1.0   // Top - Blue
]);

function setupColorTriangle(gl) {
    const vertexShader = createShader(gl, gl.VERTEX_SHADER, colorVertexShaderSource);
    const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, colorFragmentShaderSource);
    const program = createProgram(gl, vertexShader, fragmentShader);
    
    const buffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
    gl.bufferData(gl.ARRAY_BUFFER, colorVertices, gl.STATIC_DRAW);
    
    const positionLocation = gl.getAttribLocation(program, 'a_position');
    const colorLocation = gl.getAttribLocation(program, 'a_color');
    const timeLocation = gl.getUniformLocation(program, 'u_time');
    
    return { program, buffer, positionLocation, colorLocation, timeLocation };
}

function renderColorTriangle(gl, triangle, time) {
    gl.clearColor(0.1, 0.1, 0.1, 1.0);
    gl.clear(gl.COLOR_BUFFER_BIT);
    
    gl.useProgram(triangle.program);
    
    // Set time uniform
    gl.uniform1f(triangle.timeLocation, time);
    
    gl.bindBuffer(gl.ARRAY_BUFFER, triangle.buffer);
    
    // Position attribute (2 floats, starting at offset 0)
    gl.enableVertexAttribArray(triangle.positionLocation);
    gl.vertexAttribPointer(triangle.positionLocation, 2, gl.FLOAT, false, 5 * 4, 0);
    
    // Color attribute (3 floats, starting at offset 8 bytes)
    gl.enableVertexAttribArray(triangle.colorLocation);
    gl.vertexAttribPointer(triangle.colorLocation, 3, gl.FLOAT, false, 5 * 4, 2 * 4);
    
    gl.drawArrays(gl.TRIANGLES, 0, 3);
}
```

<div style={{border: '1px solid #ccc', padding: '20px', margin: '20px 0', background: '#f9f9f9'}}>
<canvas id="color-triangle-canvas" width="400" height="300" style={{border: '1px solid #333', display: 'block', margin: '0 auto'}}></canvas>
<p style={{textAlign: 'center', marginTop: '10px'}}><em>Animated Rainbow Triangle - Watch it spin and pulse!</em></p>
</div>

<script>
{`
// Demo 3: Animated Color Triangle
const colorCanvas = document.getElementById('color-triangle-canvas');
if (colorCanvas) {
    const gl = colorCanvas.getContext('webgl2') || colorCanvas.getContext('webgl');
    if (gl) {
        const colorVertexShaderSource = \`
            attribute vec2 a_position;
            attribute vec3 a_color;
            uniform float u_time;
            varying vec3 v_color;
            
            void main() {
                float angle = u_time;
                float cos_a = cos(angle);
                float sin_a = sin(angle);
                
                vec2 rotated = vec2(
                    a_position.x * cos_a - a_position.y * sin_a,
                    a_position.x * sin_a + a_position.y * cos_a
                );
                
                gl_Position = vec4(rotated, 0.0, 1.0);
                v_color = a_color;
            }
        \`;
        
        const colorFragmentShaderSource = \`
            precision mediump float;
            varying vec3 v_color;
            uniform float u_time;
            
            void main() {
                float pulse = (sin(u_time * 3.0) + 1.0) / 2.0;
                gl_FragColor = vec4(v_color * (0.5 + pulse * 0.5), 1.0);
            }
        \`;
        
        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            return shader;
        }
        
        function createProgram(gl, vertexShader, fragmentShader) {
            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            return program;
        }
        
        const vertexShader = createShader(gl, gl.VERTEX_SHADER, colorVertexShaderSource);
        const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, colorFragmentShaderSource);
        const program = createProgram(gl, vertexShader, fragmentShader);
        
        const colorVertices = new Float32Array([
            -0.5, -0.5,  1.0, 0.0, 0.0,
             0.5, -0.5,  0.0, 1.0, 0.0,
             0.0,  0.5,  0.0, 0.0, 1.0
        ]);
        
        const buffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.bufferData(gl.ARRAY_BUFFER, colorVertices, gl.STATIC_DRAW);
        
        const positionLocation = gl.getAttribLocation(program, 'a_position');
        const colorLocation = gl.getAttribLocation(program, 'a_color');
        const timeLocation = gl.getUniformLocation(program, 'u_time');
        
        gl.viewport(0, 0, colorCanvas.width, colorCanvas.height);
        
        function render(time) {
            time *= 0.001; // Convert to seconds
            
            gl.clearColor(0.1, 0.1, 0.1, 1.0);
            gl.clear(gl.COLOR_BUFFER_BIT);
            
            gl.useProgram(program);
            gl.uniform1f(timeLocation, time);
            
            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
            
            gl.enableVertexAttribArray(positionLocation);
            gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 5 * 4, 0);
            
            gl.enableVertexAttribArray(colorLocation);
            gl.vertexAttribPointer(colorLocation, 3, gl.FLOAT, false, 5 * 4, 2 * 4);
            
            gl.drawArrays(gl.TRIANGLES, 0, 3);
            
            requestAnimationFrame(render);
        }
        
        requestAnimationFrame(render);
    }
}
`}
</script>

## 3D Transformation Matrices

Now let's move into 3D space with a rotating cube:

### Interactive 3D Cube

```javascript
// 3D vertex shader with model-view-projection matrix
const cube3DVertexShader = `
    attribute vec3 a_position;
    attribute vec3 a_color;
    
    uniform mat4 u_mvpMatrix;
    
    varying vec3 v_color;
    
    void main() {
        gl_Position = u_mvpMatrix * vec4(a_position, 1.0);
        v_color = a_color;
    }
`;

const cube3DFragmentShader = `
    precision mediump float;
    varying vec3 v_color;
    
    void main() {
        gl_FragColor = vec4(v_color, 1.0);
    }
`;

// Cube vertices (8 vertices, each with position and color)
const cubeVertices = new Float32Array([
    // Front face
    -0.5, -0.5,  0.5,  1.0, 0.0, 0.0,  // Bottom left
     0.5, -0.5,  0.5,  0.0, 1.0, 0.0,  // Bottom right
     0.5,  0.5,  0.5,  0.0, 0.0, 1.0,  // Top right
    -0.5,  0.5,  0.5,  1.0, 1.0, 0.0,  // Top left
    
    // Back face
    -0.5, -0.5, -0.5,  1.0, 0.0, 1.0,  // Bottom left
     0.5, -0.5, -0.5,  0.0, 1.0, 1.0,  // Bottom right
     0.5,  0.5, -0.5,  1.0, 1.0, 1.0,  // Top right
    -0.5,  0.5, -0.5,  0.5, 0.5, 0.5   // Top left
]);

// Cube indices (36 indices for 12 triangles)
const cubeIndices = new Uint16Array([
    // Front face
    0, 1, 2,  2, 3, 0,
    // Back face
    4, 5, 6,  6, 7, 4,
    // Left face
    7, 3, 0,  0, 4, 7,
    // Right face
    1, 5, 6,  6, 2, 1,
    // Top face
    3, 2, 6,  6, 7, 3,
    // Bottom face
    0, 1, 5,  5, 4, 0
]);

// Matrix utility functions
function createPerspectiveMatrix(fov, aspect, near, far) {
    const f = Math.tan(Math.PI * 0.5 - 0.5 * fov);
    const rangeInv = 1.0 / (near - far);
    
    return new Float32Array([
        f / aspect, 0, 0, 0,
        0, f, 0, 0,
        0, 0, (near + far) * rangeInv, -1,
        0, 0, near * far * rangeInv * 2, 0
    ]);
}

function createRotationMatrix(angleX, angleY, angleZ) {
    const cosX = Math.cos(angleX), sinX = Math.sin(angleX);
    const cosY = Math.cos(angleY), sinY = Math.sin(angleY);
    const cosZ = Math.cos(angleZ), sinZ = Math.sin(angleZ);
    
    return new Float32Array([
        cosY * cosZ, cosY * sinZ, -sinY, 0,
        sinX * sinY * cosZ - cosX * sinZ, sinX * sinY * sinZ + cosX * cosZ, sinX * cosY, 0,
        cosX * sinY * cosZ + sinX * sinZ, cosX * sinY * sinZ - sinX * cosZ, cosX * cosY, 0,
        0, 0, -3, 1  // Translation back
    ]);
}

function multiplyMatrices(a, b) {
    const result = new Float32Array(16);
    for (let i = 0; i < 4; i++) {
        for (let j = 0; j < 4; j++) {
            result[i * 4 + j] = 0;
            for (let k = 0; k < 4; k++) {
                result[i * 4 + j] += a[i * 4 + k] * b[k * 4 + j];
            }
        }
    }
    return result;
}
```

<div style={{border: '1px solid #ccc', padding: '20px', margin: '20px 0', background: '#f9f9f9'}}>
<canvas id="cube-canvas" width="400" height="300" style={{border: '1px solid #333', display: 'block', margin: '0 auto'}}></canvas>
<p style={{textAlign: 'center', marginTop: '10px'}}><em>3D Rotating Cube - Full 3D graphics in action!</em></p>
</div>

<script>
{`
// Demo 4: 3D Cube
const cubeCanvas = document.getElementById('cube-canvas');
if (cubeCanvas) {
    const gl = cubeCanvas.getContext('webgl2') || cubeCanvas.getContext('webgl');
    if (gl) {
        gl.enable(gl.DEPTH_TEST);
        
        const cube3DVertexShader = \`
            attribute vec3 a_position;
            attribute vec3 a_color;
            uniform mat4 u_mvpMatrix;
            varying vec3 v_color;
            
            void main() {
                gl_Position = u_mvpMatrix * vec4(a_position, 1.0);
                v_color = a_color;
            }
        \`;
        
        const cube3DFragmentShader = \`
            precision mediump float;
            varying vec3 v_color;
            
            void main() {
                gl_FragColor = vec4(v_color, 1.0);
            }
        \`;
        
        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            return shader;
        }
        
        function createProgram(gl, vertexShader, fragmentShader) {
            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            return program;
        }
        
        const vertexShader = createShader(gl, gl.VERTEX_SHADER, cube3DVertexShader);
        const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, cube3DFragmentShader);
        const program = createProgram(gl, vertexShader, fragmentShader);
        
        const cubeVertices = new Float32Array([
            // Front face
            -0.5, -0.5,  0.5,  1.0, 0.0, 0.0,
             0.5, -0.5,  0.5,  0.0, 1.0, 0.0,
             0.5,  0.5,  0.5,  0.0, 0.0, 1.0,
            -0.5,  0.5,  0.5,  1.0, 1.0, 0.0,
            // Back face
            -0.5, -0.5, -0.5,  1.0, 0.0, 1.0,
             0.5, -0.5, -0.5,  0.0, 1.0, 1.0,
             0.5,  0.5, -0.5,  1.0, 1.0, 1.0,
            -0.5,  0.5, -0.5,  0.5, 0.5, 0.5
        ]);
        
        const cubeIndices = new Uint16Array([
            0, 1, 2,  2, 3, 0,  // Front
            4, 5, 6,  6, 7, 4,  // Back
            7, 3, 0,  0, 4, 7,  // Left
            1, 5, 6,  6, 2, 1,  // Right
            3, 2, 6,  6, 7, 3,  // Top
            0, 1, 5,  5, 4, 0   // Bottom
        ]);
        
        const vertexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, cubeVertices, gl.STATIC_DRAW);
        
        const indexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, cubeIndices, gl.STATIC_DRAW);
        
        const positionLocation = gl.getAttribLocation(program, 'a_position');
        const colorLocation = gl.getAttribLocation(program, 'a_color');
        const mvpLocation = gl.getUniformLocation(program, 'u_mvpMatrix');
        
        function createPerspectiveMatrix(fov, aspect, near, far) {
            const f = Math.tan(Math.PI * 0.5 - 0.5 * fov);
            const rangeInv = 1.0 / (near - far);
            return new Float32Array([
                f / aspect, 0, 0, 0,
                0, f, 0, 0,
                0, 0, (near + far) * rangeInv, -1,
                0, 0, near * far * rangeInv * 2, 0
            ]);
        }
        
        function createRotationMatrix(angleX, angleY, angleZ) {
            const cosX = Math.cos(angleX), sinX = Math.sin(angleX);
            const cosY = Math.cos(angleY), sinY = Math.sin(angleY);
            const cosZ = Math.cos(angleZ), sinZ = Math.sin(angleZ);
            return new Float32Array([
                cosY * cosZ, cosY * sinZ, -sinY, 0,
                sinX * sinY * cosZ - cosX * sinZ, sinX * sinY * sinZ + cosX * cosZ, sinX * cosY, 0,
                cosX * sinY * cosZ + sinX * sinZ, cosX * sinY * sinZ - sinX * cosZ, cosX * cosY, 0,
                0, 0, -3, 1
            ]);
        }
        
        function multiplyMatrices(a, b) {
            const result = new Float32Array(16);
            for (let i = 0; i < 4; i++) {
                for (let j = 0; j < 4; j++) {
                    result[i * 4 + j] = 0;
                    for (let k = 0; k < 4; k++) {
                        result[i * 4 + j] += a[i * 4 + k] * b[k * 4 + j];
                    }
                }
            }
            return result;
        }
        
        gl.viewport(0, 0, cubeCanvas.width, cubeCanvas.height);
        
        function render(time) {
            time *= 0.001;
            
            gl.clearColor(0.0, 0.0, 0.0, 1.0);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            
            const projection = createPerspectiveMatrix(Math.PI / 4, cubeCanvas.width / cubeCanvas.height, 0.1, 100);
            const modelView = createRotationMatrix(time * 0.7, time, time * 0.3);
            const mvpMatrix = multiplyMatrices(projection, modelView);
            
            gl.useProgram(program);
            gl.uniformMatrix4fv(mvpLocation, false, mvpMatrix);
            
            gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
            gl.enableVertexAttribArray(positionLocation);
            gl.vertexAttribPointer(positionLocation, 3, gl.FLOAT, false, 6 * 4, 0);
            gl.enableVertexAttribArray(colorLocation);
            gl.vertexAttribPointer(colorLocation, 3, gl.FLOAT, false, 6 * 4, 3 * 4);
            
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
            gl.drawElements(gl.TRIANGLES, cubeIndices.length, gl.UNSIGNED_SHORT, 0);
            
            requestAnimationFrame(render);
        }
        
        requestAnimationFrame(render);
    }
}
`}
</script>

## Basic Lighting with Phong Shading

Let's add realistic lighting to make our 3D objects look more convincing:

### Lit Sphere with Mouse Interaction

```javascript
// Vertex shader with normals for lighting
const lightingVertexShader = `
    attribute vec3 a_position;
    attribute vec3 a_normal;
    
    uniform mat4 u_mvpMatrix;
    uniform mat4 u_modelMatrix;
    uniform mat3 u_normalMatrix;
    
    varying vec3 v_worldPosition;
    varying vec3 v_normal;
    
    void main() {
        v_worldPosition = (u_modelMatrix * vec4(a_position, 1.0)).xyz;
        v_normal = u_normalMatrix * a_normal;
        gl_Position = u_mvpMatrix * vec4(a_position, 1.0);
    }
`;

// Fragment shader with Phong lighting
const lightingFragmentShader = `
    precision mediump float;
    
    uniform vec3 u_lightPosition;
    uniform vec3 u_lightColor;
    uniform vec3 u_objectColor;
    uniform vec3 u_viewPosition;
    
    varying vec3 v_worldPosition;
    varying vec3 v_normal;
    
    void main() {
        // Ambient lighting
        float ambientStrength = 0.1;
        vec3 ambient = ambientStrength * u_lightColor;
        
        // Diffuse lighting
        vec3 norm = normalize(v_normal);
        vec3 lightDir = normalize(u_lightPosition - v_worldPosition);
        float diff = max(dot(norm, lightDir), 0.0);
        vec3 diffuse = diff * u_lightColor;
        
        // Specular lighting
        float specularStrength = 0.5;
        vec3 viewDir = normalize(u_viewPosition - v_worldPosition);
        vec3 reflectDir = reflect(-lightDir, norm);
        float spec = pow(max(dot(viewDir, reflectDir), 0.0), 32.0);
        vec3 specular = specularStrength * spec * u_lightColor;
        
        vec3 result = (ambient + diffuse + specular) * u_objectColor;
        gl_FragColor = vec4(result, 1.0);
    }
`;

// Function to generate sphere vertices
function generateSphere(radius, latSegments, lonSegments) {
    const vertices = [];
    const normals = [];
    const indices = [];
    
    // Generate vertices and normals
    for (let lat = 0; lat <= latSegments; lat++) {
        const theta = lat * Math.PI / latSegments;
        const sinTheta = Math.sin(theta);
        const cosTheta = Math.cos(theta);
        
        for (let lon = 0; lon <= lonSegments; lon++) {
            const phi = lon * 2 * Math.PI / lonSegments;
            const sinPhi = Math.sin(phi);
            const cosPhi = Math.cos(phi);
            
            const x = cosPhi * sinTheta;
            const y = cosTheta;
            const z = sinPhi * sinTheta;
            
            vertices.push(radius * x, radius * y, radius * z);
            normals.push(x, y, z);
        }
    }
    
    // Generate indices
    for (let lat = 0; lat < latSegments; lat++) {
        for (let lon = 0; lon < lonSegments; lon++) {
            const first = (lat * (lonSegments + 1)) + lon;
            const second = first + lonSegments + 1;
            
            indices.push(first, second, first + 1);
            indices.push(second, second + 1, first + 1);
        }
    }
    
    return {
        vertices: new Float32Array(vertices),
        normals: new Float32Array(normals),
        indices: new Uint16Array(indices)
    };
}
```

<div style={{border: '1px solid #ccc', padding: '20px', margin: '20px 0', background: '#f9f9f9'}}>
<canvas id="lighting-canvas" width="400" height="300" style={{border: '1px solid #333', display: 'block', margin: '0 auto'}}></canvas>
<p style={{textAlign: 'center', marginTop: '10px'}}><em>Lit Sphere with Phong Shading - Move your mouse to control the light!</em></p>
</div>

<script>
{`
// Demo 5: Lighting
const lightingCanvas = document.getElementById('lighting-canvas');
if (lightingCanvas) {
    const gl = lightingCanvas.getContext('webgl2') || lightingCanvas.getContext('webgl');
    if (gl) {
        gl.enable(gl.DEPTH_TEST);
        
        const lightingVertexShader = \`
            attribute vec3 a_position;
            attribute vec3 a_normal;
            uniform mat4 u_mvpMatrix;
            uniform mat4 u_modelMatrix;
            uniform mat3 u_normalMatrix;
            varying vec3 v_worldPosition;
            varying vec3 v_normal;
            
            void main() {
                v_worldPosition = (u_modelMatrix * vec4(a_position, 1.0)).xyz;
                v_normal = u_normalMatrix * a_normal;
                gl_Position = u_mvpMatrix * vec4(a_position, 1.0);
            }
        \`;
        
        const lightingFragmentShader = \`
            precision mediump float;
            uniform vec3 u_lightPosition;
            uniform vec3 u_lightColor;
            uniform vec3 u_objectColor;
            uniform vec3 u_viewPosition;
            varying vec3 v_worldPosition;
            varying vec3 v_normal;
            
            void main() {
                float ambientStrength = 0.1;
                vec3 ambient = ambientStrength * u_lightColor;
                
                vec3 norm = normalize(v_normal);
                vec3 lightDir = normalize(u_lightPosition - v_worldPosition);
                float diff = max(dot(norm, lightDir), 0.0);
                vec3 diffuse = diff * u_lightColor;
                
                float specularStrength = 0.5;
                vec3 viewDir = normalize(u_viewPosition - v_worldPosition);
                vec3 reflectDir = reflect(-lightDir, norm);
                float spec = pow(max(dot(viewDir, reflectDir), 0.0), 32.0);
                vec3 specular = specularStrength * spec * u_lightColor;
                
                vec3 result = (ambient + diffuse + specular) * u_objectColor;
                gl_FragColor = vec4(result, 1.0);
            }
        \`;
        
        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            return shader;
        }
        
        function createProgram(gl, vertexShader, fragmentShader) {
            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            return program;
        }
        
        function generateSphere(radius, latSegments, lonSegments) {
            const vertices = [];
            const normals = [];
            const indices = [];
            
            for (let lat = 0; lat <= latSegments; lat++) {
                const theta = lat * Math.PI / latSegments;
                const sinTheta = Math.sin(theta);
                const cosTheta = Math.cos(theta);
                
                for (let lon = 0; lon <= lonSegments; lon++) {
                    const phi = lon * 2 * Math.PI / lonSegments;
                    const sinPhi = Math.sin(phi);
                    const cosPhi = Math.cos(phi);
                    
                    const x = cosPhi * sinTheta;
                    const y = cosTheta;
                    const z = sinPhi * sinTheta;
                    
                    vertices.push(radius * x, radius * y, radius * z);
                    normals.push(x, y, z);
                }
            }
            
            for (let lat = 0; lat < latSegments; lat++) {
                for (let lon = 0; lon < lonSegments; lon++) {
                    const first = (lat * (lonSegments + 1)) + lon;
                    const second = first + lonSegments + 1;
                    
                    indices.push(first, second, first + 1);
                    indices.push(second, second + 1, first + 1);
                }
            }
            
            return {
                vertices: new Float32Array(vertices),
                normals: new Float32Array(normals),
                indices: new Uint16Array(indices)
            };
        }
        
        const vertexShader = createShader(gl, gl.VERTEX_SHADER, lightingVertexShader);
        const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, lightingFragmentShader);
        const program = createProgram(gl, vertexShader, fragmentShader);
        
        const sphere = generateSphere(0.8, 20, 20);
        
        const vertexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, sphere.vertices, gl.STATIC_DRAW);
        
        const normalBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, sphere.normals, gl.STATIC_DRAW);
        
        const indexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, sphere.indices, gl.STATIC_DRAW);
        
        const positionLocation = gl.getAttribLocation(program, 'a_position');
        const normalLocation = gl.getAttribLocation(program, 'a_normal');
        const mvpLocation = gl.getUniformLocation(program, 'u_mvpMatrix');
        const modelLocation = gl.getUniformLocation(program, 'u_modelMatrix');
        const normalMatrixLocation = gl.getUniformLocation(program, 'u_normalMatrix');
        const lightPosLocation = gl.getUniformLocation(program, 'u_lightPosition');
        const lightColorLocation = gl.getUniformLocation(program, 'u_lightColor');
        const objectColorLocation = gl.getUniformLocation(program, 'u_objectColor');
        const viewPosLocation = gl.getUniformLocation(program, 'u_viewPosition');
        
        let mouseX = 0.5, mouseY = 0.5;
        
        lightingCanvas.addEventListener('mousemove', (e) => {
            const rect = lightingCanvas.getBoundingClientRect();
            mouseX = (e.clientX - rect.left) / rect.width;
            mouseY = 1.0 - (e.clientY - rect.top) / rect.height;
        });
        
        function createPerspectiveMatrix(fov, aspect, near, far) {
            const f = Math.tan(Math.PI * 0.5 - 0.5 * fov);
            const rangeInv = 1.0 / (near - far);
            return new Float32Array([
                f / aspect, 0, 0, 0,
                0, f, 0, 0,
                0, 0, (near + far) * rangeInv, -1,
                0, 0, near * far * rangeInv * 2, 0
            ]);
        }
        
        function createModelMatrix(time) {
            const cosY = Math.cos(time * 0.5);
            const sinY = Math.sin(time * 0.5);
            return new Float32Array([
                cosY, 0, sinY, 0,
                0, 1, 0, 0,
                -sinY, 0, cosY, 0,
                0, 0, -3, 1
            ]);
        }
        
        function multiplyMatrices(a, b) {
            const result = new Float32Array(16);
            for (let i = 0; i < 4; i++) {
                for (let j = 0; j < 4; j++) {
                    result[i * 4 + j] = 0;
                    for (let k = 0; k < 4; k++) {
                        result[i * 4 + j] += a[i * 4 + k] * b[k * 4 + j];
                    }
                }
            }
            return result;
        }
        
        gl.viewport(0, 0, lightingCanvas.width, lightingCanvas.height);
        
        function render(time) {
            time *= 0.001;
            
            gl.clearColor(0.1, 0.1, 0.1, 1.0);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            
            const projection = createPerspectiveMatrix(Math.PI / 4, lightingCanvas.width / lightingCanvas.height, 0.1, 100);
            const model = createModelMatrix(time);
            const mvp = multiplyMatrices(projection, model);
            
            const normalMatrix = new Float32Array([
                model[0], model[1], model[2],
                model[4], model[5], model[6],
                model[8], model[9], model[10]
            ]);
            
            const lightPos = [
                (mouseX - 0.5) * 4,
                (mouseY - 0.5) * 4,
                2
            ];
            
            gl.useProgram(program);
            gl.uniformMatrix4fv(mvpLocation, false, mvp);
            gl.uniformMatrix4fv(modelLocation, false, model);
            gl.uniformMatrix3fv(normalMatrixLocation, false, normalMatrix);
            gl.uniform3fv(lightPosLocation, lightPos);
            gl.uniform3f(lightColorLocation, 1.0, 1.0, 1.0);
            gl.uniform3f(objectColorLocation, 0.2, 0.6, 1.0);
            gl.uniform3f(viewPosLocation, 0, 0, 0);
            
            gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
            gl.enableVertexAttribArray(positionLocation);
            gl.vertexAttribPointer(positionLocation, 3, gl.FLOAT, false, 0, 0);
            
            gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);
            gl.enableVertexAttribArray(normalLocation);
            gl.vertexAttribPointer(normalLocation, 3, gl.FLOAT, false, 0, 0);
            
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
            gl.drawElements(gl.TRIANGLES, sphere.indices.length, gl.UNSIGNED_SHORT, 0);
            
            requestAnimationFrame(render);
        }
        
        requestAnimationFrame(render);
    }
}
`}
</script>

## Performance Tips and Best Practices for WebGL

### 1. Minimize Draw Calls
Batch similar objects together and use instanced rendering when possible:

```javascript
// Instead of multiple draw calls
for (let i = 0; i < objects.length; i++) {
    gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT, 0);
}

// Use instanced rendering or batch geometry
gl.drawElementsInstanced(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT, 0, instanceCount);
```

### 2. Optimize Shader Switching
Group objects by shader program:

```javascript
// Efficient rendering loop
const renderGroups = groupObjectsByShader(objects);
for (const group of renderGroups) {
    gl.useProgram(group.shader);
    // Set common uniforms once
    for (const object of group.objects) {
        // Set per-object uniforms and draw
    }
}
```

### 3. Use Appropriate Data Types
WebGL has specific precision requirements:

```glsl
// In fragment shaders, always specify precision
precision mediump float;  // Good balance of performance and quality
precision highp float;    // Use only when necessary
precision lowp float;     // For simple color calculations
```

### 4. Texture Management
Optimize texture usage for web delivery:

```javascript
// Load textures efficiently
function loadTexture(gl, url) {
    const texture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, texture);
    
    // Placeholder pixel while loading
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE,
                  new Uint8Array([0, 0, 255, 255]));
    
    const image = new Image();
    image.onload = () => {
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
        gl.generateMipmap(gl.TEXTURE_2D);
    };
    image.src = url;
    
    return texture;
}
```

## WebGL-Specific Debugging Techniques

### 1. Check for WebGL Errors
Always check for WebGL errors in development:

```javascript
function checkGLError(gl, operation) {
    const error = gl.getError();
    if (error !== gl.NO_ERROR) {
        console.error(`WebGL error after ${operation}: ${error}`);
        switch(error) {
            case gl.INVALID_ENUM:
                console.error('INVALID_ENUM');
                break;
            case gl.INVALID_VALUE:
                console.error('INVALID_VALUE');
                break;
            case gl.INVALID_OPERATION:
                console.error('INVALID_OPERATION');
                break;
            case gl.OUT_OF_MEMORY:
                console.error('OUT_OF_MEMORY');
                break;
        }
    }
}
```

### 2. Validate Shader Compilation
Robust shader compilation with error reporting:

```javascript
function createShader(gl, type, source) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        const info = gl.getShaderInfoLog(shader);
        console.error(`Shader compilation error:\n${info}`);
        console.error(`Source:\n${source}`);
        gl.deleteShader(shader);
        return null;
    }
    
    return shader;
}
```

### 3. Browser Developer Tools
Modern browsers have excellent WebGL debugging tools:

- **Chrome**: Use the "WebGL Inspector" extension
- **Firefox**: Built-in shader editor in developer tools
- **Safari**: WebGL debugging in Web Inspector

## Cross-Browser Compatibility

### 1. Feature Detection
Always check for WebGL support:

```javascript
function getWebGLContext(canvas) {
    const contextNames = ['webgl2', 'webgl', 'experimental-webgl'];
    
    for (const name of contextNames) {
        try {
            const gl = canvas.getContext(name);
            if (gl) {
                console.log(`Using ${name} context`);
                return gl;
            }
        } catch (e) {
            console.warn(`Failed to get ${name} context:`, e);
        }
    }
    
    throw new Error('WebGL not supported');
}
```

### 2. Extension Handling
Check for and enable necessary extensions:

```javascript
function enableExtensions(gl) {
    // For instanced rendering
    const instancedArrays = gl.getExtension('ANGLE_instanced_arrays');
    
    // For floating point textures
    const floatTextures = gl.getExtension('OES_texture_float');
    
    // For standard derivatives (dFdx, dFdy in shaders)
    const derivatives = gl.getExtension('OES_standard_derivatives');
    
    return { instancedArrays, floatTextures, derivatives };
}
```

## Next Steps and Advanced Topics

Now that you understand the fundamentals, here are advanced WebGL topics to explore:

### Advanced Rendering Techniques
- **Shadow Mapping**: Create realistic shadows
- **Post-Processing**: Screen-space effects like bloom, blur, and color grading
- **Deferred Rendering**: Handle many lights efficiently
- **Physically Based Rendering (PBR)**: Realistic material rendering

### WebGL 2.0 Features
- **Transform Feedback**: Capture vertex shader output
- **Multiple Render Targets**: Render to multiple textures simultaneously
- **3D Textures**: Volume rendering and advanced effects
- **Uniform Buffer Objects**: More efficient uniform management

### Performance Optimization
- **Frustum Culling**: Only render visible objects
- **Level of Detail (LOD)**: Use simpler models at distance
- **Texture Atlasing**: Combine textures to reduce draw calls
- **Geometry Instancing**: Render many similar objects efficiently

## Interactive Examples You Can Try

Here are some modifications you can make to the examples above:

1. **Triangle Modifications**:
   - Change colors in the fragment shader
   - Add more vertices to create different shapes
   - Experiment with vertex positions

2. **Animation Experiments**:
   - Try different rotation axes and speeds
   - Add scaling or translation animations
   - Combine multiple transformation effects

3. **Lighting Variations**:
   - Change light colors and intensities
   - Add multiple light sources
   - Experiment with different material properties

## Resources for Continued Learning

### Essential WebGL Resources
- **[WebGL Fundamentals](https://webglfundamentals.org/)** - Comprehensive WebGL tutorial series
- **[three.js](https://threejs.org/)** - Popular WebGL library for easier 3D development
- **[Shadertoy](https://www.shadertoy.com/)** - Online shader editor and gallery
- **[OpenGL ES Specification](https://www.khronos.org/opengles/)** - Technical reference

### Mathematics for Graphics
- **Linear Algebra**: Essential for transformations and lighting
- **Vector Mathematics**: Understanding dot products, cross products, and normalization
- **Matrix Operations**: Transformations, projections, and view matrices
- **Trigonometry**: For rotations, animations, and wave effects

### Graphics Programming Books
- *"Real-Time Rendering"* by Möller, Haines, and Hoffman
- *"Computer Graphics: Principles and Practice"* by Hughes, et al.
- *"Mathematics for 3D Game Programming and Computer Graphics"* by Lengyel

## Building Your Own Projects

Start with these project ideas to solidify your understanding:

### Beginner Projects
1. **Animated Solar System**: Planets orbiting around a sun
2. **3D Model Viewer**: Load and display simple 3D models
3. **Particle System**: Create snow, rain, or fire effects
4. **Simple Game**: Pong or Tetris in 3D

### Intermediate Projects
1. **Terrain Renderer**: Generate and render landscapes
2. **Water Simulation**: Animated water with reflections
3. **Skeletal Animation**: Animate 3D characters
4. **Ray Tracer**: Implement ray tracing in shaders

## Conclusion

WebGL brings the power of hardware-accelerated 3D graphics to the web browser, making it accessible to millions of users without requiring plugins or special software. Through these interactive examples, you've learned the fundamental concepts that apply to all modern graphics programming:

- **Vertex and Fragment Shaders**: The building blocks of the graphics pipeline
- **3D Transformations**: Moving objects in 3D space with matrices
- **Lighting Models**: Creating realistic surface appearance
- **Performance Optimization**: Keeping your graphics running smoothly

The key to mastering graphics programming is practice and experimentation. Start with the examples in this tutorial, modify them, break them, and rebuild them. Each experiment will deepen your understanding of how modern graphics work.

Remember that WebGL is based on OpenGL ES, so the concepts you've learned here transfer directly to mobile development, desktop applications, and other graphics platforms. Whether you're building games, data visualizations, or interactive art, these fundamentals will serve you well.

The graphics programming community is vibrant and helpful. Don't hesitate to share your creations, ask questions, and explore the amazing work others are doing with WebGL. The web is becoming an increasingly powerful platform for 3D graphics, and you're now equipped to be part of that exciting future.
